#include "canvas.h"
#include <color/color.h>
#include <lodepng/lodepng.h>
#include <iostream>
#include <string>
#include <vector>

/**
 * @file    canvas.cpp
 * @author  Eric Turner <elturner@eecs.berkeley.edu>
 * @brief   The canvas repesents the output image that was generated
 *
 * @section DESCRIPTION
 *
 * This file contains the canvas_t class, which is used to represent
 * the output image that was generated by processing, as observed from
 * the scene's camera.
 *
 * The canvas stores the aggregate colors and has the ability to export
 * to file.
 */

using namespace std;

/*-------------------------*/
/* function implementation */
/*-------------------------*/

canvas_t::canvas_t(size_t w, size_t h)
{
	this->set_size(w, h);
}
		
void canvas_t::clear()
{
	size_t i, n;

	/* reset pixels and counts */
	n = this->pixels.size();
	for(i = 0; i < n; i++)
	{
		this->pixels[i].set(0.0f, 0.0f, 0.0f);
		this->counts[i] = 0;
	}
}
		
void canvas_t::set_size(size_t w, size_t h)
{
	this->width = w;
	this->height = h;
	this->pixels.clear();
	this->pixels.resize(w*h, color_t());
	this->counts.clear();
	this->counts.resize(w*h, 0);
}
		
void canvas_t::add_pixel(size_t i, size_t j, const color_t& c)
{
	size_t index;

	/* get index of pixel (i,j) */
	index = j*(this->width) + i;

	/* add sample */
	this->pixels[index] += c;
	this->counts[index] ++;
}
		
void canvas_t::add_coord(float u, float v, const color_t& c)
{
	size_t i, j;

	/* get pixel that corresponds to these coordinates */
	i = (size_t) floor(this->width  * u);
	j = (size_t) floor(this->height * v);

	/* add sample to pixel */
	this->add_pixel(i, j, c);
}
		
int canvas_t::writepng(const std::string& filename) const
{
	vector<unsigned char> image; /* RGBA pixel values */
	color_t avg;
	size_t i, n;
	unsigned int error;

	/* create list of pixels to encode as a png */
	n = this->pixels.size();
	image.resize(4 * n);
	for(i = 0; i < n; i++)
	{
		/* get average color for the current pixel */
		avg = this->pixels[i] * (1.0f / this->counts[i]);
		/* convert color value to RGBA pixels (four indices) */
		image[4*i]     = avg.get_red_int();
		image[4*i + 1] = avg.get_green_int();
		image[4*i + 2] = avg.get_blue_int();
		image[4*i + 3] = 255; /* alpha value */
	}

	/* encode as a png */
	error = lodepng::encode(filename.c_str(), image,
				this->width, this->height);
	if(error)
	{
		/* report error */
		cerr << "[canvas_t::writepng]\tError " << error << ": "
		     << "Unable to export to .png file: " << filename 
		     << endl << lodepng_error_text(error) << endl;
		return -1;
	}

	/* success */
	return 0;
}

/*-------------------------*/
/* static helper functions */
/*-------------------------*/

void canvas_t::unittest()
{
	canvas_t canvas;
	color_t color;
	unsigned int r, c, width, height;
	int ret; 

	/* set the size */
	width = height = 512;
	canvas.set_size(width, height);

	/* populate some pixels */
	for(r = 0; r < height; r++)
		for(c = 0; c < width; c++)
		{
			color.set_ints(255 * !(c & r), 
					255 & (c ^ r),
					255 & (c | r));
			canvas.add_pixel(c, r, color);
		}

	/* export */
	ret = canvas.writepng("unittest.png");
	if(ret)
	{
		/* report error and exit */
		cerr << "[main]\tError " << ret << ": Unable to export"
		     << endl;
	}
}
